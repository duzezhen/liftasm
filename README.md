# liftasm

## Introduction

Alignment-based coordinate liftover for assemblies and GFA graphs.

## Requirements

Please note the following requirements before building and running the software:

- `Linux` operating system
- `GCC ≥ 12.2.0` (with `C++20` support)
- `CMake ≥ 3.20`
- `zlib`, `bzip2`, `liblzma` (xz)
- `Git` (for submodules)

Optional:
- `libcurl` (`htslib` will be built without `libcurl` support if not available)

## Installation

### Building on Linux

Use the following script to build the software:

```shell
git clone https://github.com/duzezhen/liftasm.git
cd liftasm
git submodule update --init --recursive
rm -rf build
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build -j 5
./build/liftasm
```

If you would like to enable CPU-specific optimizations (e.g., `-march=native`), you can compile with:

```shell
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DLIFTASM_ENABLE_NATIVE=ON
```

## Usage

`liftasm` provides several subcommands for graph transformation and coordinate liftover.

### Main Subcommands

- **deoverlap**  
  Replace overlaps between nodes in a `hifiasm` GFA graph with single nodes, converting an overlap assembly graph into a non-overlap graph.

- **collapse**  
  Collapse homologous segments within bubbles in a non-overlap graph into single nodes, generating a collapsed graph.

- **file2map**  
  Convert GFA or PAF files into coordinate mapping files:
  - From GFA: extract coordinate relationships between `S` nodes and `A`-line reads.
  - From PAF: extract coordinate relationships from alignment intervals.

- **liftover**  
  Perform coordinate liftover using mapping files generated by `deoverlap`, `collapse`, and `file2map`.

- **mapq_boost**  
  Boost MAPQ scores for reads aligned to homologous regions.

### Mapping Files

During `deoverlap` and `collapse`, the following mapping files are generated:

- `prefix.deoverlap.map`
- `prefix.collapse.map`

These describe homologous relationships between nodes in the `p_utg` graph.

## Example Workflow (`hifiasm` output prefix: `HG002.asm`)

### 1. Transform the graph

```bash
liftasm deoverlap -t 20 -g HG002.asm.bp.p_utg.gfa -p out
liftasm collapse  -t 20 -g out.deoverlap.gfa      -p out
```

### 2. Build mapping files

```bash
liftasm file2map -i HG002.asm.bp.p_utg.gfa       -o HG002.asm.bp.p_utg.map
liftasm file2map -i HG002.asm.bp.hap1.p_ctg.gfa  -o HG002.asm.bp.hap1.p_ctg.map
liftasm file2map -i HG002.asm.bp.hap2.p_ctg.gfa  -o HG002.asm.bp.hap2.p_ctg.map
```

Combine all maps:

```bash
cat out.deoverlap.map \
    out.collapse.map \
    HG002.asm.bp.p_utg.map \
    HG002.asm.bp.hap1.p_ctg.map \
    HG002.asm.bp.hap2.p_ctg.map \
    > merge.map
```

This merged map enables coordinate translation such as:

```bash
hap1.p_ctg -> read -> p_utg1 -> p_utg2 -> read -> hap2.p_ctg
```

Homologous node relationships inside `p_utg` are defined by `deoverlap` and `collapse`, and are represented as `p_utg1 -> p_utg2`.

### 3. MAPQ Boosting

If reads align to homologous regions (e.g., `hap1+hap2` or `p_utg`), MAPQ may be reduced to 0.
`mapq_boost` corrects these cases using mapping relationships.

```bash
cat HG002.asm.bp.hap1.p_ctg.fa HG002.asm.bp.hap2.p_ctg.fa > HG002.merge.fa

bwa mem -SP5M -k 25 -t 24 HG002.merge.fa HG002.HiC.R1.fq.gz HG002.HiC.R2.fq.gz \
  | liftasm mapq_boost -t 24 --io_threads 24 -m merge.map \
  | samtools view -@24 -b -q 10 -o HG002.boost.bam
```

If you already have a BAM file:

```bash
liftasm mapq_boost -t 24 --io_threads 24 -i HG002.bam -m merge.map \
  | samtools view -@24 -b -q 10 -o HG002.boost.bam
```

### 4. Liftover to Reference

1. Align haplotypes to reference:

```bash
minimap2 -t8 -cx asm5 --secondary=no reference.fa HG002.merge.fa > HG002.paf
```

2. Convert PAF to map:

```bash
liftasm file2map -i HG002.paf -o HG002.paf.map
```

3. Merge maps:

```bash
cat merge.map HG002.paf.map > merge.plus_paf.map
```

4. Perform liftover:

```bash
liftasm liftover -m merge.plus_paf.map --paf HG002.paf -b your_pos.bed
```

The `--paf` option is optional but recommended for improved accuracy.

## Liftover Parameter

`--cm_max_hops` controls how many mapping hops are allowed during liftover.

Example path:

```bash
hap1.p_ctg -> read -> p_utg1 -> p_utg2 -> read -> hap2.p_ctg
```

- `--cm_max_hops 0` -> stops at `read`
- `--cm_max_hops 1` -> reaches `p_utg1`
- `--cm_max_hops 2` -> reaches `p_utg2`

Higher values increase runtime.

## Limitations

1. This is a newly developed project and may contain unresolved issues. If you encounter any problems, please feel free to contact us.

2. When assembly quality is low, the `collapse` step may be incomplete. As a result, some homologous relationships may not be detected.

3. For graphs generated from ultra-long read assemblies, the `collapse` step may also be incomplete.

4. Currently, `collapse` is designed for typical (non-cancer) genome assemblies. In cancer genomes, the graph structure can become highly complex, which may prevent correct bubble detection and collapsing of some homologous nodes.

## License

MIT